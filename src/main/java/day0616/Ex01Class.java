package day0616;

// Class
// Java 에서의 프로그램 하나하나를 뜻함.
// 지금까지 만든 프로그램은 3세대 객체지향적 언어의 관점에서는 클래스라고 부를 수 없었다.
// 그 이유는, 클래스는 반드시 데이터를 저장할 공간과 해당 클래스 변수들이
// 실행할 수 있는 기능이 같이 정의되어있어야 했지만
// 우리는 지금까지 둘 중 하나만 정의해왔기 때문이다.

// 프로그램을 기능의 집합이라고 생각했던 2세대 절차지향적 언어와 다르게
// 3세대 객체지향적 언어에서는 프로그램을 더 작은 프로그램 변수의 집합으로 본다.

// 즉 학생과 관련된 프로그램을 만들게 될때
// 학생과 관련한 클래스를 만들어서 그 안에
// 해당 클래스 변수, 즉
// 1. 어떠한 정보를 가질지
// 2. 그 객체들이 실행시킬 메소드를 정의하고,
// 필요할 때 마다 그 객체들을 만들어서 사용하게 된다.

// 클래스의 구성
// 필드 + 메소드

// 필드 : 해당 클래스의 객체들이 가지고 있을 데이터들의 종류
// 메소드 : 해당 클래스의 객체들이 실행가능한 기능들

// static 키워드는 객체지향적 프로그래밍에서는 사용을 기피해야하는 키워드이다.
// 그 이유는, static 키워드가 붙으면 해당 메소드를
// 객체를 따로 생성하지 않고 메소드만 불러와서 사용을 하겠다는 의마가 되기 때문에
// 반드시 객체 생성을 거쳐야 하는 객체지향적 관점에서는 static 키워드는 사용을 피해야한다.

// 객체 vs 인스턴스
// 객체 : 클래스 타입의 변수 전체(인스턴스를 포함하는 개념)
// 인스턴스 : 실체화(초기화)가 된 객체

public class Ex01Class {
    // 클래스 안의 필드는 이전의 구조체와 같은방식으로 구현된다.
    // 즉, 해당 클래스 변수들이 어떠너 데이터를 저장 가능한지를 우리는 선언만 해주고
    // 실제 데이터의 저장은 해당 객체를 초기화한 인스턴스에서 이루어진다.

    // 클래스 안의 메소드는
    // 해당 클래스 변수를 만들고 나서
    // 그 객체들이 공통적으로 실행시킬 수 있도록 만들어 주되,
    // 앞에서 설명했듯이 더이상 static 키워드는 사용하지 않는다.

    // 생성자(constructor)
    // 생성자란 객체를 생성할 때 실행시킬 코드를 모아둔 메소드이다.
    // 우리가 특별히 성성자를 따로 정의하지 않더라도
    // 자바가 기본적으로 제공해주는 기본 생성자가
    // 해당 객체의 필드를 초기화 시켜주는 역할
    // 단, 이때에는 기본형 데이터타입의 필드는 0으로
    // 참조형 데이터타입의 필드는 null로 초기화해준다.

    // 생성자는 리턴타입이 없고,
    // 메소드 이름이 클래스 이름과 일치해야한다.

    // 필요에 따라서는 우리가 직접 생성자를 정의해 줄수도 있는데
    // 이때에는 한가지 주의할 점이
    // 파라미터를 갖는 생성자를 만들어 주게되면,
    // 파라미터를 갖지않는 생성자는 사용할 수 없다.

    // 오버라이드(Override)
    // 부모 클래스로부터 상속받은 메소드를 자식클래스가 재정의 하는 것.
    // 단, 오버라이드의 주의점은
    // 해당 메소드를 선언할 때, 반드시 부모클래스가 적은 것을 똑같이 적어야 한다.

    // 호출 순위
    // 똑같은 개념끼리는 동일한 이름을 부여할 수 없지만
    // 필드와 메소드변수는 서로 다른 개념이기때문에
    // 동일한 이름을 부여할 수 있는 대신,
    // 해당 메소드에서는 같은 이름이면
    // 변수를 뜻하게 된다.
    // 만약 필드와 메소드변수가 같은 이름을 가지면
    // 해당 변수에서 필드를 호출할 때에는
    // "이 메소드를 실행하는 객체" 라는 뜻을 가진
    // this 라는 키워드를 사용하게 된다.
    // 즉, 어떠한 파라미터로 값을 받아올 때
    // 필드와 파라미터의 이름이 같을 경우
    // this.필드 = 파라미터
    // 로 필드에 입력받은 파라미터를 저장해준다.

    // 접근제한자(Access Modifier)
    // 필드 / 메소드를 외부클래스가 접근 가능 여부를 제어하는 키워드이다.

    // public: 해당 필드 / 메소드를 다른 패키지의 다른 클래스도 접근할 수 있게 한다.
    // protected: 같은 패키지의 다른 클래스는 사용 가능하지만 외부 패키지의 다른 클래스는 상속관계가 아니면 접근할 수 없다.
    // default: 같은 패키지의 다른클래스들만 접근 가능
    // switch 문에서 default 라는 키워드를 사용하기 때문에 접근제한자를 적어주지 않으면 된다.
    // 다른이름으로 "패키지 접근제한자" 라고 한다.
    // private: 해당 클래스 내부에서만 사용한다 라는 의미로써
    // 다른 클래스면 패키지에 관계없이 접근할 수 없다.

    // 캡슐화(데이터 은닉)
    // 기본적으로 만드는 객체 안의 세부내용을 외부에 알리지 않고 다 숨기겠다 라는 의미
    // 외부가 반드시 사용해야 할 메소드 외에는 전부다 직접적인 접근을 막는것이다.
    //  이렇게 직접적인 접근을 막고 꼭 알아야 할 메소드만 공개하는것을
    // 캡슐화 라고 부른다.

    // 캡슐화의 가장 핵심은 접근을 막는 것이므로
    // 기존에는 public 접근제한자만 사용했지만
    // 앞으로 private 를 같이 사용함

    // getter / setter
    // 겟터/셋터는 객체의 필드를 캡슐화하는 방법으로써
    // 우리가 앞으로는 모든 필드에 private 접근 제한자를 적용시키면
    // 더이상 외부클래스가 해당 필드에 직접 값을 저장하거나, 저장된 값을 호출 불가능하게 된다.
    // 대신 겟터/셋터 메소드를 통해 값을 저장하거나 저장된 값을 호출하게 된다.

    // Getter : 겟터는 현재 필드에 저장된 값을 불러오는 메소드이다.
    // 겟터는 다음과 같은 형식을 가진다
    // public 필드타입 get필드이름() {
    //      return 필드이름;
    //}

    // Setter : 해당 필드에 외부의 값을 저장하는 메소드이다
    // 셋터는 다음과 같은 형식을 가진다.
    //    public void set필드이름(필드와 동일한 파라미터) {
    //        this.필드 = 파라미터;
    //    }
}
































